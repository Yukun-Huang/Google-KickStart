# C. Funniest Word Search

### 描述

1.给定一个**R**行**C**列的矩形网格，我们需要找到隐藏在网格里的所有合法单词。每个单词可能水平或者竖直地出现（不会有对角），正序或逆序。隐藏的单词可能重叠。

2.给定一个有**W**个不同单词的词典。每个单词可能出现在网格中一次或多次，或者一个也没有。

3.现在的网格太大了，我们需要找到一个非空的、网格对齐（即矩形）的子网格。我们希望找到一个具有最大fun值的子网格。fun值计算如下：

               fun value = (total length of words matched) / ((width of subgrid) + (height of subgrid))

注意：

1.整个单词必须都出现在子网格里才算数。

2.如果一个单词在子网格里出现了x次，那它的长度也要乘以x倍。

3.如果一个单词和它的逆序都出现在网格中（甚至同一位置），我们算作两种情况。

4.有最大fun值的子网格可能是整个原来的网格。

特殊限制：

1.字典里的单词不会出现两次。

2.字典里所有单词加起来的总长度不会超过5000个字母。

目标：

找到有最大fun值的子网格，以及它的个数。两个子网格不同，当且仅当有一些cell在一个子网格中，但不在另一个里。

输出：

Fun值的最简分数形式  子网格个数

### 分析

对于小数据集，每个word只有一个字母，因此可以这样做：对于RxC的矩形，遍历每一网格计算其匹配长度，即fun值的分子部分。时间复杂度为O(RCW)。

接着，我们使用一个二维累积数组，使得我们可以以O(1)时间查询某一子网格区域的匹配长度，进而以O(1)时间计算某一子网格区域的fun值。

最后，我们需要遍历所有子网格。遍历子网格可以通过两重for循环分别遍历子区域的左上方块和右下方块。时间复杂度为O(R^2*C^2).

以上就是小数据集的暴力解法。

### 记录

1.对于小数据集，时间限制是240秒，即4分钟，而本地需要近5分钟的时间跑完，因此谷歌服务器的速度大概比本地快1.25倍以上。

### 代码积累

二维累积数组，最大公约数，子网格遍历
