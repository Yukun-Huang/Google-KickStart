# A. Candies

### 描述

给定一个整数数组，判断是否存在一个连续子集，使得：

1.其所有项的和不超过D

2.奇数项数目不大于O

如果存在，找出这些子集的所有项之和中的最大值，否则输出IMPOSSIBLE.

### 分析

首先对数组遍历一遍，计算前i项和，后续就可以用常数时间查询一个连续区间的累加和。

对于这类连续子区间的问题，通常可以考虑采用双指针法构建一个滑动区间来解决。

对于小数据集，不存在负数。我们首先构建一个for循环遍历左边界。对于每一个固定的左边界值，我们去找到满足约束条件的最大右边界，因为不存在负数，所以这时也就对应了最优解。直接遍历查询最大右边界的话，时间复杂度是O(n^2)，但实际上没有必要重复查询，因为符合当前左边界约束条件的最大右边界，在左边界+1后必然也满足，从而右边界的查询不必从头开始，这样就可以将时间复杂度优化为O(n).

对于大数据集，因为多了负数的存在，此时最优解不一定位于最大右边界了。在小数据集解法的基础上，我们保留滑动窗口法和奇数约束条件的判定，可以得到当前左边界及其满足奇数项条件的最大右边界，记为[L,SO]，最优解对应的右边界R就在该区间里。这时的最优解等于最大化sweetness = sum(1,R)-sum(1,L-1)，且不超过D.这里要求找到一个受约束条件下的最大值，可以想到c++的multiset结构（平衡二叉搜索树）去实现对数级的查找。我们不断地通过插入和删除去维护一个前缀和的树，以便查找最优解对应的R.最终的时间复杂度为O(nlogn).

### 算法

见上面。

### 代码积累

双指针法，滑动窗口，平衡二叉搜索树，STL multiset.
