# B.Lucky Dip

### 描述

给你一个有N个物品的袋子，每个物品有不同的价值，你从中抽到每个物品的概率均等。如果允许你放回K次（放回去后仍然概率均等），而且你要尽可能地使抽出来的物品价值最大，那么这个物品的价值的期望是多少。

### 分析

从最简单的情况开始分析。

假如K=0,不允许放回，那么无论采取什么策略，期望E[0]只能是所有物品的价值均值。

假如K=1,那么选择放回以后，后续的期望就等于E[0].因此最优策略是，在第一次抽取到物品后，如果该物品价值大于E[0]，则不放回，这种策略能够取得最大期望。
也就是：

E[0] = Σ Vi / N

E[1] = Σ max(Vi, E[0]) / N

这就是small dataset的情况，时间复杂度为O(N).

假如K=2,那么在第一次选择放回以后，就变成了K=1的情况，期望为E[1].因此，同样的，如果在第一次抽取到物品后，如果该物品价值大于E[1]，则不放回，那么：

E[2] = Σ max(Vi, E[1]) / N

很显然，当K>2时，也可以一直递归下去，即：

E[K] = Σ max(Vi, E[K-1]) / N

### 算法

1.计算期望E[0].

2.通过迭代公式计算E[K].

可以看出，直接计算的话，时间复杂度为O(NK)，似乎不是很理想。那么是否还有优化的空间呢。首先，递归的过程不可避免，就是说K是没法省的，那么从N处着手优化。求和的操作导致了复杂度为O(N).以计算E[K]为例，如果V事先排序好，那么通过二分搜索就能找到大于E[K-1]的项的数目xk，于是:

  E[k] = xk * E[k - 1] / N + Σi>xk Vi / N
  
首先对V排序，并且计算数组V的后缀和。

