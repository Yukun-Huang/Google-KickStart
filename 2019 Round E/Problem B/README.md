## B. Code-Eat Switcher

### 描述

假设一天可以分为S个时间段。然后每个时间段Si分别可以选择得到Ci的编程点数或者Ei的吃饭点数。我们可以选择一个[0,1]范围内的实数f控制这两个动作的比例。例如，可以得到f*Ci的编程点数和(1-f)*Ei的吃饭点数。

在接下来的D天里，每天都有规定的编程和吃饭计划。例如，第i天需要完成Ai编程点数和Bi吃饭点数。问这D天的目标完成情况（是否可以达成目标）。

### 分析

#### 小数据集

我们先对每天分别进行处理。

对于每天的目标targetC和targetE，我们不妨假设所有的时间都用来coding，这样能得到totalC的编程点数。
显然，如果totalC < targetC，这天显然不能完成。
否则，我们假设多出来的编程点数ableC = totalC - targetC，这些多出来的点数将被用于转化成吃饭点数。

我们肯定更偏好效率高的转化，比如我同样减少1单位的编程效率，希望能增加最大的吃饭点数。
所以我们要把slots按照吃饭/编程转化率 R = E/C 从大到小排序。
然后依次遍历，如果在ableC减到0之前能达到targetE，那么这天是可行的，否则不可行。

时间复杂度为O(DS)，可以解决小数据集。

#### 大数据集

在按照吃饭/编程转化率从大到小对C和E进行排序后，我们可以预先计算C和E的前缀和。
如此一来，我们就可以先对E的前缀和数组用二分搜索，以O(log S)的时间复杂度去确定targetE的下界
(大于等于targetE的第一个元素)，然后再计算所需的最小编程点数needC。

最后，比较needC和ableC的大小即可，如果needC大于等于ableC，则可完成目标，否则不可完成。

总的时间复杂度为O(DlogS).

### 关键词

排序，前缀和，二分查找

