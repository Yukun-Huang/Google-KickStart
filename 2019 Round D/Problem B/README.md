### B. Latest Guests

### 描述

给定N个大使馆，依次排列构成一个环。给定G个访客，其中第i个访客的起点为Hi，Hi在其中一个大使馆中。
这些访客在接下来的M分钟里会顺时针或逆时针移动，分别用C或A表示。

每经过一分钟，访客会到达一个相邻的大使馆。大使馆会记住最后一次到达的那些访客。
问：每个访客各自被多少个大使馆记住？

### 分析

**对于小数据集**：

暴力解法，仿真整个过程。遍历时间和访客。对于每一分钟，更新所有大使馆的访问状态。

时间复杂度为O(M*G)，空间复杂度为O(N*G).

**对于大数据集**：

思路: 首先不难想到, 如果m>=2*n, 那么除了第一次走n步，其余的走n步都是对第一次过程的重复，
所以如果m>=2*n,则m=n+(m%n). 这样m就缩小到1e5级别了。

我们先看顺时针的情况: 对于某一个点i，谁会经过它? 肯定是从i往逆时针走m步，若路过的点上有人，
那么这个人肯定会经过点i. 那么谁会最后一个经过i? 肯定是走m步/最后遇到的/有人的那个点/上的人(有点绕口,已断句)。

那么对于点i，我们维护一个往前走m步的一个队列，若队列不为空，那么队列的front就是最后一个经过i的人。
对于i+1来说，我们只需要看队列首部那个人的位置是不是距离(i+1)超过了m，如果超过了m则将其pop掉即可。
然后再看i+1这个点是否存在顺时针走的人，若存在则将其push到队列尾部即可。

逆时针类似。

[原文出处](https://blog.csdn.net/Frozensmile/article/details/97799228)

### 关键词

无


